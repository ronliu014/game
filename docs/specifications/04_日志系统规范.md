# 日志系统规范

## 文档版本
- **版本号**: v1.0.0
- **创建日期**: 2026-01-19
- **最后更新**: 2026-01-19
- **文档状态**: 正式版

---

## 1. 概述

### 1.1 目的
本规范定义项目的日志记录标准，确保日志的一致性、可追溯性和可分析性。良好的日志是问题排查、性能分析和系统监控的基础。

### 1.2 适用范围
- 所有源代码模块
- 游戏运行时日志
- 错误和异常记录
- 性能监控日志
- 调试信息

### 1.3 设计原则
1. **结构化**: 使用统一的日志格式
2. **分级记录**: 根据重要性分级
3. **关键路径必记**: 重要事件必须记录
4. **性能友好**: 避免过度日志影响性能
5. **安全第一**: 不记录敏感信息

---

## 2. 日志级别定义

### 2.1 级别说明

| 级别 | 名称 | 用途 | 是否记录文件 | 示例场景 |
|------|------|------|--------------|----------|
| DEBUG | 调试 | 详细的调试信息 | 开发环境 | 变量值、函数调用、算法步骤 |
| INFO | 信息 | 关键操作信息 | 是 | 游戏启动、关卡加载、状态变更 |
| WARNING | 警告 | 潜在问题提醒 | 是 | 配置缺失、资源未找到（已降级处理） |
| ERROR | 错误 | 错误但不影响运行 | 是 | 资源加载失败、连接超时 |
| CRITICAL | 严重 | 严重错误，需立即处理 | 是 | 系统崩溃、数据损坏 |

### 2.2 级别使用指南

#### DEBUG - 调试级别
```python
# ✅ 正确使用
logger.debug(f"Grid initialized with size: {grid_size}")
logger.debug(f"Tile rotation: ({x}, {y}) -> {rotation}°")
logger.debug(f"Connectivity check result: {is_connected}")

# ❌ 错误使用
logger.debug("Starting function")  # 太泛化
logger.debug(f"User password: {password}")  # 敏感信息
```

#### INFO - 信息级别
```python
# ✅ 正确使用
logger.info("Game started")
logger.info(f"Level loaded: {level_id}")
logger.info(f"Player completed level {level_id} in {time}s")
logger.info("Audio system initialized")

# ❌ 错误使用
logger.info(f"Mouse moved to ({x}, {y})")  # 太频繁
logger.info("Function returned")  # 无意义
```

#### WARNING - 警告级别
```python
# ✅ 正确使用
logger.warning(f"Configuration file not found, using defaults: {config_path}")
logger.warning(f"Texture quality degraded due to memory limit")
logger.warning(f"Level {level_id} not found, loading default level")

# ❌ 错误使用
logger.warning("This might be slow")  # 不具体
```

#### ERROR - 错误级别
```python
# ✅ 正确使用
logger.error(f"Failed to load level {level_id}: {error}", exc_info=True)
logger.error(f"Audio file not found: {audio_path}")
logger.error(f"Network request failed: {url}", extra={'status_code': 404})

# ❌ 错误使用
logger.error("Something went wrong")  # 不具体
logger.error("Error")  # 无上下文
```

#### CRITICAL - 严重级别
```python
# ✅ 正确使用
logger.critical(f"Game engine initialization failed: {error}", exc_info=True)
logger.critical(f"Corrupted save data detected: {save_path}")
logger.critical("Out of memory, forcing shutdown")

# ❌ 错误使用
logger.critical("Button clicked")  # 级别过高
```

---

## 3. 日志格式规范

### 3.1 标准日志格式

```
[时间戳] [级别] [模块名] [函数名:行号] - 消息内容 {上下文数据}
```

#### 示例
```
[2026-01-19 14:23:45.123] [INFO] [core.level.level_manager] [load_level:45] - Level loaded successfully {'level_id': '001', 'grid_size': 4, 'load_time_ms': 125}

[2026-01-19 14:23:50.456] [ERROR] [rendering.sprite_manager] [load_sprite:89] - Failed to load sprite {'sprite_path': 'assets/tiles/missing.png', 'error': 'FileNotFoundError'}

[2026-01-19 14:24:01.789] [WARNING] [audio.audio_manager] [play_sound:102] - Sound file not found, using default {'requested': 'custom_click.wav', 'fallback': 'default_click.wav'}
```

### 3.2 时间戳格式
```python
# 标准格式：YYYY-MM-DD HH:MM:SS.mmm
format: '%(asctime)s'
datefmt: '%Y-%m-%d %H:%M:%S'
# 毫秒部分自动添加
```

### 3.3 结构化日志（JSON格式）

对于需要机器分析的日志，使用JSON格式：

```json
{
  "timestamp": "2026-01-19T14:23:45.123Z",
  "level": "INFO",
  "module": "core.level.level_manager",
  "function": "load_level",
  "line": 45,
  "message": "Level loaded successfully",
  "context": {
    "level_id": "001",
    "grid_size": 4,
    "load_time_ms": 125,
    "tiles_count": 16
  }
}
```

---

## 4. 日志配置

### 4.1 配置文件结构

创建 `data/config/logging_config.json`:

```json
{
  "version": 1,
  "disable_existing_loggers": false,
  "formatters": {
    "standard": {
      "format": "[%(asctime)s] [%(levelname)s] [%(name)s] [%(funcName)s:%(lineno)d] - %(message)s",
      "datefmt": "%Y-%m-%d %H:%M:%S"
    },
    "simple": {
      "format": "[%(levelname)s] %(message)s"
    },
    "json": {
      "()": "src.utils.logger.JsonFormatter"
    }
  },
  "handlers": {
    "console": {
      "class": "logging.StreamHandler",
      "level": "INFO",
      "formatter": "simple",
      "stream": "ext://sys.stdout"
    },
    "file": {
      "class": "logging.handlers.RotatingFileHandler",
      "level": "DEBUG",
      "formatter": "standard",
      "filename": "logs/game.log",
      "maxBytes": 10485760,
      "backupCount": 5,
      "encoding": "utf8"
    },
    "error_file": {
      "class": "logging.handlers.RotatingFileHandler",
      "level": "ERROR",
      "formatter": "standard",
      "filename": "logs/error.log",
      "maxBytes": 10485760,
      "backupCount": 5,
      "encoding": "utf8"
    },
    "performance_file": {
      "class": "logging.handlers.RotatingFileHandler",
      "level": "INFO",
      "formatter": "json",
      "filename": "logs/performance.log",
      "maxBytes": 10485760,
      "backupCount": 3,
      "encoding": "utf8"
    }
  },
  "loggers": {
    "": {
      "level": "DEBUG",
      "handlers": ["console", "file", "error_file"]
    },
    "performance": {
      "level": "INFO",
      "handlers": ["performance_file"],
      "propagate": false
    }
  }
}
```

### 4.2 环境配置

| 环境 | 日志级别 | 输出位置 | 文件大小限制 |
|------|----------|----------|--------------|
| 开发环境 | DEBUG | 控制台 + 文件 | 10MB |
| 测试环境 | INFO | 文件 | 50MB |
| 生产环境 | WARNING | 文件 + 远程 | 100MB |

---

## 5. 日志实现

### 5.1 Logger工具类

创建 `src/utils/logger.py`:

```python
"""
日志工具模块

提供统一的日志记录接口，支持结构化日志和上下文信息。
"""

import logging
import logging.config
import json
from pathlib import Path
from typing import Any, Dict, Optional
from datetime import datetime


class JsonFormatter(logging.Formatter):
    """JSON格式化器"""

    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            'timestamp': datetime.utcfromtimestamp(record.created).isoformat() + 'Z',
            'level': record.levelname,
            'module': record.name,
            'function': record.funcName,
            'line': record.lineno,
            'message': record.getMessage(),
        }

        # 添加额外的上下文数据
        if hasattr(record, 'context'):
            log_data['context'] = record.context

        # 添加异常信息
        if record.exc_info:
            log_data['exception'] = self.formatException(record.exc_info)

        return json.dumps(log_data, ensure_ascii=False)


class GameLogger:
    """游戏日志管理器"""

    _initialized = False

    @classmethod
    def initialize(cls, config_path: str = 'data/config/logging_config.json'):
        """
        初始化日志系统

        Args:
            config_path: 日志配置文件路径
        """
        if cls._initialized:
            return

        # 创建日志目录
        log_dir = Path('logs')
        log_dir.mkdir(exist_ok=True)

        # 加载配置
        if Path(config_path).exists():
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            logging.config.dictConfig(config)
        else:
            # 使用默认配置
            logging.basicConfig(
                level=logging.DEBUG,
                format='[%(asctime)s] [%(levelname)s] [%(name)s] [%(funcName)s:%(lineno)d] - %(message)s',
                datefmt='%Y-%m-%d %H:%M:%S'
            )

        cls._initialized = True

    @staticmethod
    def get_logger(name: str) -> logging.Logger:
        """
        获取Logger实例

        Args:
            name: Logger名称（通常使用 __name__）

        Returns:
            logging.Logger: Logger实例
        """
        return logging.getLogger(name)

    @staticmethod
    def log_with_context(logger: logging.Logger, level: int, message: str,
                        context: Optional[Dict[str, Any]] = None):
        """
        记录带上下文的日志

        Args:
            logger: Logger实例
            level: 日志级别
            message: 日志消息
            context: 上下文数据（字典）
        """
        if context:
            message = f"{message} {json.dumps(context, ensure_ascii=False)}"
        logger.log(level, message)


# 性能日志专用
performance_logger = logging.getLogger('performance')


def log_performance(operation: str, duration_ms: float, **kwargs):
    """
    记录性能日志

    Args:
        operation: 操作名称
        duration_ms: 持续时间（毫秒）
        **kwargs: 额外的上下文信息
    """
    context = {
        'operation': operation,
        'duration_ms': round(duration_ms, 2),
        **kwargs
    }
    performance_logger.info(f"Performance: {operation}", extra={'context': context})
```

### 5.2 使用示例

#### 基本使用
```python
from src.utils.logger import GameLogger

# 在程序启动时初始化（只需一次）
GameLogger.initialize()

# 在模块中使用
logger = GameLogger.get_logger(__name__)

# 记录日志
logger.info("Game started")
logger.debug(f"Grid size: {grid_size}")
logger.error(f"Failed to load level: {level_id}", exc_info=True)
```

#### 带上下文的日志
```python
from src.utils.logger import GameLogger

logger = GameLogger.get_logger(__name__)

# 方式1：使用字典
context = {
    'level_id': '001',
    'grid_size': 4,
    'tiles_count': 16
}
GameLogger.log_with_context(logger, logging.INFO, "Level loaded", context)

# 方式2：使用extra参数
logger.info("Level loaded", extra={
    'context': {
        'level_id': '001',
        'grid_size': 4
    }
})
```

#### 性能日志
```python
from src.utils.logger import log_performance
import time

start_time = time.time()
# ... 执行操作 ...
duration_ms = (time.time() - start_time) * 1000

log_performance(
    operation='level_loading',
    duration_ms=duration_ms,
    level_id='001',
    tiles_count=16
)
```

#### 装饰器方式
```python
import functools
import time
from src.utils.logger import GameLogger, log_performance

logger = GameLogger.get_logger(__name__)


def log_execution(func):
    """记录函数执行的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        logger.debug(f"Calling {func.__name__} with args={args}, kwargs={kwargs}")

        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            duration_ms = (time.time() - start_time) * 1000

            logger.debug(f"{func.__name__} completed in {duration_ms:.2f}ms")
            log_performance(func.__name__, duration_ms)

            return result
        except Exception as e:
            logger.error(f"{func.__name__} failed: {e}", exc_info=True)
            raise

    return wrapper


# 使用装饰器
@log_execution
def load_level(level_id: str):
    # 加载关卡逻辑
    pass
```

---

## 6. 关键记录点

### 6.1 游戏生命周期
```python
# ✅ 必须记录
logger.info("Game starting")
logger.info("Game initialized successfully")
logger.info("Game shutting down")
logger.info("Game terminated")
```

### 6.2 关卡管理
```python
# ✅ 必须记录
logger.info(f"Loading level: {level_id}")
logger.info(f"Level loaded: {level_id}", extra={'context': level_stats})
logger.info(f"Level completed: {level_id}", extra={'context': completion_stats})
logger.error(f"Level loading failed: {level_id}", exc_info=True)
```

### 6.3 游戏状态变更
```python
# ✅ 必须记录
logger.info(f"Game state changed: {old_state} -> {new_state}")
logger.info(f"Player action: {action_type}", extra={'context': action_data})
```

### 6.4 资源加载
```python
# ✅ 必须记录
logger.info(f"Loading resources from: {resource_path}")
logger.warning(f"Resource not found, using fallback: {resource_path}")
logger.error(f"Failed to load critical resource: {resource_path}", exc_info=True)
```

### 6.5 错误和异常
```python
# ✅ 必须记录，包含exc_info
try:
    dangerous_operation()
except Exception as e:
    logger.error(f"Operation failed: {operation_name}", exc_info=True)
    # 或者使用 logger.exception()
    logger.exception(f"Operation failed: {operation_name}")
```

### 6.6 性能关键点
```python
# ✅ 必须记录性能数据
log_performance('grid_connectivity_check', duration_ms, grid_size=4, tiles_count=16)
log_performance('sprite_rendering', duration_ms, sprite_count=50, fps=60)
log_performance('level_loading', duration_ms, level_id='001')
```

---

## 7. 日志禁忌

### 7.1 绝对禁止

```python
# ❌ 禁止：记录密码、密钥等敏感信息
logger.debug(f"User credentials: {username}:{password}")
logger.info(f"API key: {api_key}")

# ❌ 禁止：记录个人隐私信息
logger.info(f"User email: {email}, phone: {phone}")

# ❌ 禁止：在循环中高频记录
for i in range(1000000):
    logger.debug(f"Processing item {i}")  # 会生成海量日志

# ❌ 禁止：记录完整的大对象
logger.debug(f"Full game state: {entire_game_state_object}")

# ❌ 禁止：无意义的日志
logger.info("Here")
logger.debug("Test")
logger.info("Function started")
```

### 7.2 应该避免

```python
# ⚠️ 避免：日志信息不明确
logger.error("Error occurred")  # 什么错误？
logger.info("Success")  # 什么成功了？

# ⚠️ 避免：过度使用字符串格式化
logger.debug("Value is " + str(value))  # 应使用 f-string

# ⚠️ 避免：记录不必要的调试信息到生产环境
if DEBUG:
    logger.debug(f"Internal state: {state}")  # 应该但有条件
```

---

## 8. 日志文件管理

### 8.1 文件轮转策略

```python
# 基于大小轮转
RotatingFileHandler(
    filename='logs/game.log',
    maxBytes=10485760,  # 10MB
    backupCount=5,      # 保留5个备份
    encoding='utf8'
)

# 基于时间轮转
TimedRotatingFileHandler(
    filename='logs/game.log',
    when='midnight',    # 每天午夜轮转
    interval=1,         # 间隔1天
    backupCount=7,      # 保留7天
    encoding='utf8'
)
```

### 8.2 日志文件命名

```
logs/
├── game.log              # 当前日志
├── game.log.1            # 第1个备份
├── game.log.2            # 第2个备份
├── error.log             # 错误日志
├── performance.log       # 性能日志
└── 2026-01-19.log        # 按日期归档（可选）
```

### 8.3 日志清理策略

```python
# 创建清理脚本: tools/scripts/clean_logs.py
import os
from datetime import datetime, timedelta
from pathlib import Path

def clean_old_logs(log_dir: str = 'logs', days: int = 30):
    """
    清理超过指定天数的日志文件

    Args:
        log_dir: 日志目录
        days: 保留天数
    """
    log_path = Path(log_dir)
    cutoff_date = datetime.now() - timedelta(days=days)

    for log_file in log_path.glob('*.log*'):
        if log_file.stat().st_mtime < cutoff_date.timestamp():
            log_file.unlink()
            print(f"Deleted old log: {log_file}")
```

---

## 9. 日志分析

### 9.1 常用分析命令

```bash
# 查看错误日志
grep ERROR logs/game.log

# 统计各级别日志数量
grep -o "\[.*\]" logs/game.log | sort | uniq -c

# 查看最近的错误
tail -n 100 logs/error.log

# 实时监控日志
tail -f logs/game.log

# 查找特定关卡的日志
grep "level_001" logs/game.log

# 分析性能日志（需要jq工具）
cat logs/performance.log | jq '.context.duration_ms' | awk '{sum+=$1; count++} END {print "Average:", sum/count}'
```

### 9.2 日志分析工具推荐

- **grep/awk/sed**: 命令行文本处理
- **jq**: JSON日志处理
- **Elastic Stack (ELK)**: 企业级日志分析（可选）
- **Grafana + Loki**: 可视化日志分析（可选）

---

## 10. 性能优化

### 10.1 避免性能影响

```python
# ✅ 正确：使用惰性求值
logger.debug("Grid state: %s", grid_state)  # 只在需要时格式化

# ❌ 错误：预先格式化
logger.debug(f"Grid state: {expensive_serialization(grid_state)}")  # 总是执行

# ✅ 正确：条件检查
if logger.isEnabledFor(logging.DEBUG):
    logger.debug(f"Expensive debug info: {expensive_operation()}")
```

### 10.2 异步日志（可选）

对于高性能要求的场景，可以使用异步日志：

```python
from logging.handlers import QueueHandler, QueueListener
import queue

# 创建队列
log_queue = queue.Queue()

# 使用队列处理器
queue_handler = QueueHandler(log_queue)
logger.addHandler(queue_handler)

# 在后台线程处理日志
listener = QueueListener(log_queue, file_handler, console_handler)
listener.start()
```

---

## 11. 日志安全

### 11.1 敏感信息脱敏

```python
import re

def mask_sensitive_data(message: str) -> str:
    """脱敏处理敏感信息"""
    # 脱敏邮箱
    message = re.sub(r'([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})',
                     r'\1***@\2', message)

    # 脱敏手机号（保留前3后4位）
    message = re.sub(r'(\d{3})\d{4}(\d{4})', r'\1****\2', message)

    # 脱敏密钥（只显示前后各4位）
    message = re.sub(r'(key|token|password)["\s:=]+([a-zA-Z0-9]{4})[a-zA-Z0-9]+([a-zA-Z0-9]{4})',
                     r'\1: \2****\3', message, flags=re.IGNORECASE)

    return message


# 使用自定义过滤器
class SensitiveDataFilter(logging.Filter):
    def filter(self, record):
        record.msg = mask_sensitive_data(str(record.msg))
        return True

logger.addFilter(SensitiveDataFilter())
```

### 11.2 日志访问控制

```
# 日志文件权限设置（Linux/macOS）
chmod 640 logs/*.log  # 所有者读写，组只读，其他无权限

# Windows: 使用文件属性设置访问权限
```

---

## 12. 测试与验证

### 12.1 日志测试

```python
import unittest
from unittest.mock import patch
import logging

class TestLogging(unittest.TestCase):

    def test_logger_initialization(self):
        """测试日志初始化"""
        GameLogger.initialize()
        logger = GameLogger.get_logger('test')
        self.assertIsNotNone(logger)

    def test_log_levels(self):
        """测试日志级别"""
        logger = GameLogger.get_logger('test')

        with self.assertLogs(logger, level='INFO') as cm:
            logger.info("Test info message")
            logger.error("Test error message")

        self.assertEqual(len(cm.output), 2)
        self.assertIn('INFO', cm.output[0])
        self.assertIn('ERROR', cm.output[1])
```

### 12.2 日志验证清单

- [ ] 所有关键路径都有日志记录
- [ ] 日志级别使用正确
- [ ] 日志消息清晰明确
- [ ] 包含足够的上下文信息
- [ ] 无敏感信息泄露
- [ ] 异常包含堆栈信息
- [ ] 性能日志完整
- [ ] 日志文件正常轮转

---

## 13. 常见问题

### Q1: 日志太多影响性能怎么办？
**A**:
1. 检查DEBUG日志是否过多，生产环境应使用INFO或WARNING
2. 避免在循环中记录日志
3. 使用惰性求值和条件检查
4. 考虑异步日志

### Q2: 如何调试线上问题？
**A**:
1. 查看error.log定位错误
2. 根据时间戳关联相关日志
3. 使用grep过滤关键字
4. 分析性能日志找出瓶颈

### Q3: 日志文件过大怎么办？
**A**:
1. 使用RotatingFileHandler限制单文件大小
2. 定期清理过期日志
3. 压缩归档旧日志
4. 考虑使用远程日志服务

### Q4: 如何统一团队日志风格？
**A**:
1. 强制使用本规范
2. 代码审查检查日志质量
3. 提供日志工具类和装饰器
4. 建立日志示例库

---

## 14. 文档变更记录

| 版本 | 日期 | 修改人 | 修改内容 |
|------|------|--------|----------|
| v1.0.0 | 2026-01-19 | Claude | 初始版本，定义完整的日志系统规范 |

---

**重要提示**:
1. 日志是问题排查的唯一依据，必须认真对待
2. 关键操作必须记录日志
3. 日志质量直接影响维护效率
4. 遵循本规范是强制要求，不是建议
