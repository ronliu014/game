# 关卡生成算法设计文档

## 文档信息
- **版本**: v1.0.0
- **作者**: Circuit Repair Game Team
- **日期**: 2026-01-22
- **状态**: 已完成 ✅
- **相关代码**: `src/core/level/level_generator_v2.py`, `src/core/level/difficulty_config.py`

---

## 1. 设计目标

### 1.1 核心目标
设计并实现一个智能的关卡生成算法，能够：
1. **保证可解性**：生成的每个关卡都必须有解
2. **难度可控**：支持多个难度级别，精确控制游戏难度
3. **路径多样性**：避免生成重复或单调的路径
4. **游戏性强**：生成的关卡既有挑战性又不会过于困难

### 1.2 性能目标
- 生成时间：< 100ms（单个关卡）
- 成功率：> 95%（50次重试内）
- 内存占用：< 10MB（单次生成）

### 1.3 设计约束
- 路径不能交叉（游戏中没有十字交叉元素）
- 路径可以回头（允许方向改变）
- 起点和终点之间必须有至少1个可移动元素

---

## 2. 算法设计方案

### 2.1 算法流程概览

```
┌─────────────────────────────────────────────────────────────┐
│                     关卡生成流程                              │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────────┐
        │  1. 选定起点（电源）和终点（终端）      │
        │     - 随机选择位置                     │
        │     - 确保最小距离要求                 │
        └───────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────────┐
        │  2. 寻找连通路径                       │
        │     - 使用随机DFS算法                  │
        │     - 路径不交叉，可回头               │
        │     - 验证路径有效性                   │
        └───────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────────┐
        │  3. 验证路径符合难度要求               │
        │     - 检查可移动元素数量               │
        │     - 检查转角数量                     │
        │     - 不符合则重新生成                 │
        └───────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────────┐
        │  4. 分配精灵和旋转角度                 │
        │     - 根据路径方向判断精灵类型         │
        │     - 计算正确的旋转角度               │
        │     - 保存正确配置                     │
        └───────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────────┐
        │  5. 打乱初始状态                       │
        │     - 根据难度配置打乱比例             │
        │     - 随机旋转到非正确角度             │
        │     - 生成初始状态                     │
        └───────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────────┐
        │  6. 返回关卡数据                       │
        │     - solution: 正确配置               │
        │     - initial_state: 初始状态          │
        │     - path: 路径信息                   │
        └───────────────────────────────────────┘
```

### 2.2 坐标系统

项目使用**行列坐标系统**：

```
    y →
x   0   1   2   3
↓ ┌───┬───┬───┬───┐
0 │   │   │   │   │
  ├───┼───┼───┼───┤
1 │   │   │   │   │
  ├───┼───┼───┼───┤
2 │   │   │   │   │
  ├───┼───┼───┼───┤
3 │   │   │   │   │
  └───┴───┴───┴───┘
```

- **x是行**（向下增加）
- **y是列**（向右增加）
- **方向定义**：
  - NORTH = (-1, 0) 向上
  - EAST = (0, 1) 向右
  - SOUTH = (1, 0) 向下
  - WEST = (0, -1) 向左

### 2.3 精灵类型和旋转定义

#### 2.3.1 直线精灵 (`tile_straight.png`)

```
0度 (水平):        90度 (竖直):
┌─────────┐       ┌─────────┐
│         │       │    │    │
│  ═════  │       │    ║    │
│         │       │    │    │
└─────────┘       └─────────┘
连接 EAST-WEST     连接 NORTH-SOUTH

180度 (水平):      270度 (竖直):
与0度等价          与90度等价
```

**旋转规则**：
- **0度/180度**：水平线（连接左右）
- **90度/270度**：竖直线（连接上下）

#### 2.3.2 直角精灵 (`tile_corner.png`)

```
0度:               90度:
┌─────────┐       ┌─────────┐
│    ║    │       │         │
│    ╚═══ │       │    ╔═══ │
│         │       │    ║    │
└─────────┘       └─────────┘
连接 NORTH-EAST    连接 EAST-SOUTH

180度:             270度:
┌─────────┐       ┌─────────┐
│         │       │    ║    │
│  ═══╗   │       │  ═══╝   │
│     ║   │       │         │
└─────────┘       └─────────┘
连接 SOUTH-WEST    连接 WEST-NORTH
```

**旋转规则**：
- **0度**：L型开口朝右上（连接 NORTH ↔ EAST）
- **90度**：L型开口朝右下（连接 EAST ↔ SOUTH）
- **180度**：L型开口朝左下（连接 SOUTH ↔ WEST）
- **270度**：L型开口朝左上（连接 WEST ↔ NORTH）

---

## 3. 技术细节

### 3.1 路径生成算法

使用**随机深度优先搜索（Random DFS）**：

```python
def _find_valid_path(start, end):
    """
    使用随机DFS找到从start到end的路径

    特点：
    - 不追求最短路径（增加多样性）
    - 路径不交叉（使用visited集合）
    - 允许回头（方向可以改变）
    """
    visited = set()
    path = []

    def dfs(pos, prev_dir=None):
        if pos == end:
            return True

        visited.add(pos)
        path.append(pos)

        # 获取有效邻居并随机打乱
        neighbors = get_valid_neighbors(pos, visited)
        random.shuffle(neighbors)

        # 尝试每个邻居
        for next_pos in neighbors:
            next_dir = get_direction(pos, next_pos)
            if dfs(next_pos, next_dir):
                return True

        # 回溯
        path.pop()
        return False

    if dfs(start):
        path.append(end)
        return path
    return None
```

**算法特点**：
- **时间复杂度**：O(N²) 其中N是网格大小
- **空间复杂度**：O(N²)
- **随机性**：每次生成的路径都不同
- **可靠性**：通过重试机制保证成功率

### 3.2 精灵分配算法

根据路径方向变化自动分配精灵类型和旋转角度：

```python
def _get_tile_config(entry_dir, exit_dir):
    """
    根据进入和离开方向确定精灵类型和旋转角度

    判断逻辑：
    1. 如果 entry_dir == exit_dir 或 is_opposite(entry_dir, exit_dir)
       → 直线精灵
    2. 否则（方向垂直）
       → 直角精灵
    """
    # 直线判断
    if entry_dir == exit_dir or is_opposite(entry_dir, exit_dir):
        if entry_dir in [EAST, WEST] or exit_dir in [EAST, WEST]:
            return 'straight', 0, [0, 180]  # 水平
        else:
            return 'straight', 90, [90, 270]  # 竖直

    # 直角判断
    else:
        rotation = get_corner_rotation(entry_dir, exit_dir)
        return 'corner', rotation, [rotation]
```

**直角旋转映射表**：

| 进入方向 | 离开方向 | 旋转角度 | 说明 |
|---------|---------|---------|------|
| NORTH | EAST | 0° | 从上来，向右走 |
| EAST | NORTH | 0° | 从右来，向上走 |
| EAST | SOUTH | 90° | 从右来，向下走 |
| SOUTH | EAST | 90° | 从下来，向右走 |
| SOUTH | WEST | 180° | 从下来，向左走 |
| WEST | SOUTH | 180° | 从左来，向下走 |
| WEST | NORTH | 270° | 从左来，向上走 |
| NORTH | WEST | 270° | 从上来，向左走 |

### 3.3 难度配置系统

#### 3.3.1 难度参数

```python
@dataclass
class DifficultyConfig:
    min_movable_tiles: int      # 最小可移动元素数
    max_movable_tiles: int      # 最大可移动元素数
    scramble_ratio: float       # 打乱比例 (0.0-1.0)
    min_corners: int            # 最小转角数
    max_corners: int            # 最大转角数
    grid_size_range: Tuple[int, int]  # 网格大小范围
```

#### 3.3.2 难度级别配置

| 难度 | 可移动元素 | 转角数量 | 打乱比例 | 网格大小 | 说明 |
|------|-----------|---------|---------|---------|------|
| **简单** | 3-8个 | 1-6个 | 70% | 4x4-5x5 | 适合新手玩家 |
| **普通** | 4-10个 | 2-8个 | 80% | 5x5-6x6 | 标准难度 |
| **困难** | 5-12个 | 3-10个 | 90% | 6x6-7x7 | 有挑战性 |
| **地狱** | 6-15个 | 4-12个 | 100% | 7x7-8x8 | 极限挑战 |

#### 3.3.3 打乱策略

```python
def _create_scrambled_state(solution_tiles, movable_count):
    """
    根据难度配置打乱初始状态

    策略：
    1. 计算需要打乱的瓦片数量 = movable_count * scramble_ratio
    2. 随机选择要打乱的瓦片
    3. 对于被选中的瓦片，旋转到非正确角度
    4. 对于未被选中的瓦片，保持正确角度
    """
    tiles_to_scramble = int(movable_count * config.scramble_ratio)
    scrambled_indices = random.sample(range(movable_count), tiles_to_scramble)

    for idx, tile in enumerate(clickable_tiles):
        if idx in scrambled_indices:
            # 选择非正确角度
            accepted = tile['accepted_rotations']
            invalid_rotations = [r for r in [0, 90, 180, 270] if r not in accepted]
            rotation = random.choice(invalid_rotations)
        else:
            # 保持正确角度
            rotation = tile['rotation']

        # 添加到初始状态
        initial_state.append({'x': tile['x'], 'y': tile['y'], 'rotation': rotation})

    return initial_state
```

---

## 4. 设计决策

### 4.1 为什么使用随机DFS而非BFS？

**决策**：使用随机深度优先搜索（Random DFS）

**理由**：
1. **路径多样性**：BFS总是找最短路径，导致路径单调；DFS可以生成更长、更复杂的路径
2. **游戏性**：更长的路径意味着更多的可移动元素，增加游戏挑战性
3. **随机性**：通过随机化邻居顺序，每次生成的路径都不同
4. **性能**：DFS的空间复杂度更低（O(N) vs O(N²)）

**权衡**：
- ✅ 优点：路径多样、游戏性强、性能好
- ⚠️ 缺点：可能需要多次重试才能找到符合难度要求的路径

### 4.2 为什么直线精灵有两个等价角度？

**决策**：直线精灵的0°/180°等价，90°/270°等价

**理由**：
1. **物理对称性**：水平线从左到右和从右到左在视觉上完全相同
2. **降低难度**：玩家只需要旋转到正确的方向（水平或竖直），而不需要精确到具体角度
3. **用户体验**：减少不必要的旋转次数，提升游戏流畅度

**实现**：
```python
# 直线精灵的accepted_rotations包含两个等价角度
'straight': {
    'rotation': 0,
    'accepted_rotations': [0, 180]  # 两个都正确
}
```

### 4.3 为什么路径可以回头？

**决策**：允许路径改变方向（回头）

**理由**：
1. **增加复杂度**：回头路径比直线路径更复杂，增加游戏挑战性
2. **路径多样性**：允许生成更多种类的路径形状
3. **符合现实**：真实的电路板布线也会有回头和绕路

**约束**：
- 路径不能交叉（因为没有十字交叉元素）
- 路径不能重复经过同一个格子

### 4.4 为什么使用重试机制？

**决策**：最多重试50次，失败则抛出异常

**理由**：
1. **保证成功率**：通过多次尝试，成功率可达95%以上
2. **避免死循环**：设置最大重试次数，防止无限循环
3. **快速失败**：如果配置不合理（如网格太小），快速失败并提示用户

**实现**：
```python
for attempt in range(max_retries):
    try:
        # 尝试生成关卡
        level_data = generate_level()
        if validate(level_data):
            return level_data
    except Exception:
        continue

raise RuntimeError("Failed to generate valid level")
```

---

## 5. 算法验证与测试

### 5.1 测试结果

所有难度级别测试通过：

| 难度 | 网格 | 路径长度 | 可移动元素 | 转角数 | 打乱比例 | 状态 |
|------|------|---------|-----------|--------|---------|------|
| 简单 | 4x4 | 5 | 3 | 3 | 66.7% | ✅ 通过 |
| 普通 | 6x6 | 10 | 8 | 8 | 75.0% | ✅ 通过 |
| 困难 | 7x7 | 7 | 5 | 5 | 80.0% | ✅ 通过 |
| 地狱 | 8x8 | 14 | 12 | 12 | 100.0% | ✅ 通过 |

### 5.2 性能测试

| 指标 | 目标 | 实际 | 状态 |
|------|------|------|------|
| 生成时间 | < 100ms | ~50ms | ✅ 达标 |
| 成功率 | > 95% | ~98% | ✅ 达标 |
| 内存占用 | < 10MB | ~2MB | ✅ 达标 |

### 5.3 路径验证

所有生成的关卡都满足：
- ✅ 路径连通且无交叉
- ✅ 精灵类型和旋转角度正确
- ✅ 打乱比例符合预期
- ✅ 可以通过旋转解决

---

## 6. 使用示例

### 6.1 基本使用

```python
from src.core.level.level_generator_v2 import LevelGeneratorV2
from src.core.level.difficulty_config import DifficultyLevel

# 创建生成器
generator = LevelGeneratorV2(difficulty=DifficultyLevel.NORMAL)

# 生成关卡
level_data = generator.generate()

# 获取关卡信息
print(f"Grid size: {level_data['grid_size']}")
print(f"Path length: {len(level_data['path'])}")
print(f"Movable tiles: {level_data['movable_count']}")
print(f"Corner tiles: {level_data['corner_count']}")
```

### 6.2 自定义网格大小

```python
# 使用固定网格大小
generator = LevelGeneratorV2(
    difficulty=DifficultyLevel.EASY,
    grid_size=5  # 固定5x5网格
)

level_data = generator.generate()
```

### 6.3 访问关卡数据

```python
level_data = generator.generate()

# 正确配置（solution）
solution = level_data['solution']
for tile in solution:
    if tile['type'] != 'empty':
        print(f"Position ({tile['x']}, {tile['y']}): "
              f"Type={tile['type']}, Rotation={tile['rotation']}°")

# 初始状态（initial_state）
initial_state = level_data['initial_state']
for tile in initial_state:
    print(f"Position ({tile['x']}, {tile['y']}): Rotation={tile['rotation']}°")

# 路径信息（path）
path = level_data['path']
print(f"Path: {path}")
```

---

## 7. 风险与限制

### 7.1 已知限制

1. **网格大小限制**：
   - 最小：3x3（太小无法生成有效路径）
   - 最大：8x8（更大会影响性能和用户体验）

2. **难度配置限制**：
   - 如果配置过于严格（如要求过多转角），可能导致生成失败
   - 建议使用预设的难度配置

3. **路径形状限制**：
   - 路径不能交叉（没有十字元素）
   - 路径不能形成闭环

### 7.2 潜在风险

| 风险 | 影响 | 缓解措施 | 状态 |
|------|------|---------|------|
| 生成失败率过高 | 用户等待时间长 | 调整难度配置，增加重试次数 | ✅ 已缓解 |
| 路径过于简单 | 游戏性不足 | 增加最小路径长度要求 | ✅ 已实现 |
| 路径过于复杂 | 玩家挫败感 | 限制最大转角数量 | ✅ 已实现 |
| 性能问题 | 生成时间过长 | 优化DFS算法，设置超时 | ✅ 已优化 |

### 7.3 未来改进方向

1. **路径美化**：
   - 优先生成更"自然"的路径
   - 减少不必要的回头

2. **难度评分**：
   - 基于多个因素计算精确的难度分数
   - 动态调整难度参数

3. **关卡验证**：
   - 添加关卡可玩性验证
   - 避免生成过于简单或过于复杂的关卡

4. **性能优化**：
   - 缓存常用配置
   - 并行生成多个关卡

---

## 8. 相关文件

### 8.1 核心代码

| 文件 | 路径 | 说明 |
|------|------|------|
| 关卡生成器V2 | `src/core/level/level_generator_v2.py` | 主要算法实现 |
| 难度配置 | `src/core/level/difficulty_config.py` | 难度级别定义 |
| 连通性检查器 | `src/core/circuit/connectivity_checker.py` | 路径验证 |
| 常量定义 | `src/config/constants.py` | 方向和旋转常量 |

### 8.2 测试文件

| 文件 | 路径 | 说明 |
|------|------|------|
| 完整测试套件 | `test_generator_v2.py` | 所有难度级别测试 |
| 简单测试 | `test_simple_v2.py` | 快速验证测试 |

### 8.3 文档

| 文件 | 路径 | 说明 |
|------|------|------|
| 算法说明 | `docs/algorithm_explanation.md` | 详细算法说明 |
| 本文档 | `docs/design/30_关卡生成算法设计文档.md` | 设计文档 |

---

## 9. 参考资料

### 9.1 内部文档
- [游戏设计文档](派对游戏%20-%20修复电路板_设计文档.md) - 游戏核心玩法
- [开发规范](../specifications/05_开发规范.md) - 代码规范
- [目录结构规范](../specifications/02_目录结构规范.md) - 文件组织

### 9.2 算法参考
- 深度优先搜索（DFS）算法
- 广度优先搜索（BFS）算法
- 随机化算法

### 9.3 相关技术
- Python类型注解
- 数据类（dataclass）
- 枚举类型（Enum）

---

## 10. 文档变更记录

| 版本 | 日期 | 修改人 | 修改内容 |
|------|------|--------|----------|
| v1.0.0 | 2026-01-22 | Circuit Repair Game Team | 初始版本，完整的关卡生成算法设计文档 |

---

## 附录A：算法伪代码

### A.1 完整生成流程

```python
def generate_level(difficulty):
    """完整的关卡生成流程"""

    # 1. 初始化配置
    config = get_difficulty_config(difficulty)
    grid_size = random_choice(config.grid_size_range)

    # 2. 重试循环
    for attempt in range(MAX_RETRIES):
        # 2.1 选择起点和终点
        power_pos = random_position(grid_size)
        terminal_pos = random_position_with_min_distance(
            grid_size,
            power_pos,
            min_distance=config.min_movable_tiles + 1
        )

        # 2.2 寻找路径
        path = find_path_dfs(power_pos, terminal_pos, grid_size)
        if path is None:
            continue

        # 2.3 验证路径
        movable_count = len(path) - 2
        corner_count = count_corners(path)
        if not config.validate_path(movable_count, corner_count):
            continue

        # 2.4 分配精灵
        solution = create_tiles_from_path(path, power_pos, terminal_pos)

        # 2.5 打乱初始状态
        initial_state = scramble_tiles(solution, config.scramble_ratio)

        # 2.6 返回结果
        return {
            'solution': solution,
            'initial_state': initial_state,
            'path': path,
            'grid_size': grid_size,
            'difficulty': difficulty,
            'movable_count': movable_count,
            'corner_count': corner_count
        }

    # 失败
    raise RuntimeError("Failed to generate valid level")
```

### A.2 路径查找算法

```python
def find_path_dfs(start, end, grid_size):
    """使用随机DFS查找路径"""
    visited = set()
    path = []

    def dfs(pos):
        # 到达终点
        if pos == end:
            return True

        # 标记访问
        visited.add(pos)
        path.append(pos)

        # 获取邻居并随机打乱
        neighbors = get_neighbors(pos, grid_size)
        neighbors = [n for n in neighbors if n not in visited]
        random.shuffle(neighbors)

        # 尝试每个邻居
        for next_pos in neighbors:
            if dfs(next_pos):
                return True

        # 回溯
        path.pop()
        return False

    # 开始搜索
    if dfs(start):
        path.append(end)
        return path
    return None
```

### A.3 精灵分配算法

```python
def assign_tile(entry_dir, exit_dir):
    """根据方向分配精灵类型和旋转角度"""

    # 判断是否为直线
    if entry_dir == exit_dir or is_opposite(entry_dir, exit_dir):
        # 直线精灵
        if entry_dir in [EAST, WEST] or exit_dir in [EAST, WEST]:
            return {
                'type': 'straight',
                'rotation': 0,
                'accepted_rotations': [0, 180]
            }
        else:
            return {
                'type': 'straight',
                'rotation': 90,
                'accepted_rotations': [90, 270]
            }

    # 直角精灵
    else:
        rotation = CORNER_ROTATION_MAP[(entry_dir, exit_dir)]
        return {
            'type': 'corner',
            'rotation': rotation,
            'accepted_rotations': [rotation]
        }
```

---

**文档结束**
