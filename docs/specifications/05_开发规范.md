# 开发规范

## 文档版本
- **版本号**: v1.0.0
- **创建日期**: 2026-01-19
- **最后更新**: 2026-01-19
- **文档状态**: 正式版

---

## 1. 概述

### 1.1 目的
本规范定义项目开发的标准流程、代码风格、最佳实践，确保代码质量、可维护性和团队协作效率。

### 1.2 强制性要求
本文档中的所有规范均为**强制要求**，所有开发人员必须遵守。代码审查时将严格检查规范遵守情况。

### 1.3 适用范围
- 所有源代码
- 配置文件
- 数据文件
- 测试代码
- 工具脚本

---

## 2. 开发流程

### 2.1 开发生命周期

```
需求分析 → 技术设计 → 编码实现 → 单元测试 → 代码审查 → 集成测试 → 部署发布
```

### 2.2 Git工作流

#### 分支策略
```
main          - 主分支（稳定版本，受保护）
  └── develop - 开发分支（最新开发）
      ├── feature/xxx - 功能分支
      ├── bugfix/xxx  - 修复分支
      └── hotfix/xxx  - 紧急修复
```

#### 分支命名规范
```bash
# ✅ 正确
feature/grid-rotation-system
feature/level-loader
bugfix/sprite-loading-error
hotfix/critical-crash-on-startup

# ❌ 错误
myfeature
fix
branch1
test-branch
```

#### 提交信息规范
```bash
# 格式: <type>(<scope>): <subject>

# Type类型:
# feat:     新功能
# fix:      修复Bug
# docs:     文档更新
# style:    代码格式（不影响功能）
# refactor: 重构
# perf:     性能优化
# test:     测试相关
# chore:    构建/工具相关

# ✅ 正确示例
feat(grid): add tile rotation animation
fix(level): resolve connectivity check bug
docs(api): update integration API documentation
refactor(rendering): simplify sprite manager
perf(circuit): optimize path finding algorithm
test(grid): add unit tests for grid manager

# ❌ 错误示例
update code
fix bug
WIP
test
```

#### 提交最佳实践
```bash
# 1. 提交前检查
git status                    # 确认要提交的文件
git diff                      # 查看改动内容

# 2. 暂存文件
git add src/core/grid/        # 只添加相关文件，不要 git add .

# 3. 编写清晰的提交信息
git commit -m "feat(grid): implement tile rotation with animation

- Add rotation state tracking to Tile class
- Implement 90-degree clockwise rotation
- Add rotation animation with 300ms duration
- Update connectivity check after rotation

Closes #42"

# 4. 推送前同步
git pull --rebase origin develop
git push origin feature/grid-rotation-system
```

### 2.3 代码审查流程

#### 提交审查前检查清单
- [ ] 代码符合本规范要求
- [ ] 所有单元测试通过
- [ ] 无编译/运行错误
- [ ] 添加必要的注释和文档
- [ ] 更新相关文档
- [ ] 无调试代码和TODO残留（除非有issue跟踪）

#### 审查要点
1. **功能正确性**: 代码是否实现了需求
2. **代码质量**: 是否遵循规范和最佳实践
3. **性能**: 是否有性能问题
4. **安全性**: 是否有安全漏洞
5. **可维护性**: 代码是否易于理解和维护
6. **测试覆盖**: 测试是否充分

---

## 3. Python代码规范

### 3.1 代码风格基础

遵循 [PEP 8](https://pep8.org/) 标准，重点规则：

#### 缩进与空格
```python
# ✅ 正确: 4个空格缩进
def example_function():
    if condition:
        do_something()
    return result

# ❌ 错误: Tab或2个空格
def example_function():
  if condition:  # 2个空格
      do_something()  # Tab
```

#### 行长度
```python
# ✅ 正确: 每行最多79字符（代码），72字符（注释）
result = some_function(
    parameter1,
    parameter2,
    parameter3
)

# ❌ 错误: 超过79字符
result = some_function(parameter1, parameter2, parameter3, parameter4, parameter5, parameter6)
```

#### 空行
```python
# ✅ 正确
class GridManager:
    """网格管理器"""

    def __init__(self):
        """初始化"""
        pass

    def method1(self):
        """方法1"""
        pass


class AnotherClass:
    """另一个类"""
    pass


# ❌ 错误: 空行使用不当
class GridManager:
    def __init__(self):
        pass
    def method1(self):  # 缺少空行
        pass
class AnotherClass:  # 缺少两个空行
    pass
```

#### 导入规范
```python
# ✅ 正确: 导入顺序和分组
# 1. 标准库
import os
import sys
from typing import List, Dict, Optional

# 2. 第三方库
import pygame
import numpy as np

# 3. 本地模块
from src.core.grid import GridManager
from src.utils.logger import GameLogger

# ❌ 错误
import pygame, os, sys  # 不要一行多个导入
from src.core.grid import *  # 不要使用 *
import src.core.grid as g  # 避免无意义的缩写
```

### 3.2 命名规范

```python
# ✅ 正确命名

# 模块名: 小写+下划线
# grid_manager.py, level_loader.py

# 类名: 大驼峰（PascalCase）
class GridManager:
    pass

class TileType(Enum):
    pass

# 函数/方法名: 小写+下划线
def load_level(level_id: str):
    pass

def check_connectivity():
    pass

# 变量名: 小写+下划线
grid_size = 4
tile_rotation = 90
is_connected = True

# 常量: 全大写+下划线
MAX_GRID_SIZE = 8
DEFAULT_ROTATION = 0
TILE_SIZE_PX = 64

# 私有成员: 单下划线前缀
class Tile:
    def __init__(self):
        self._rotation = 0  # 私有属性

    def _internal_method(self):  # 私有方法
        pass

# 特殊私有成员: 双下划线前缀（名称改编）
class Grid:
    def __init__(self):
        self.__internal_state = {}  # 强私有

# ❌ 错误命名
class gridManager:  # 应该用大驼峰
    pass

def LoadLevel():  # 应该用小写+下划线
    pass

GridSize = 4  # 普通变量不应大驼峰
max_grid_size = 8  # 常量应全大写
```

### 3.3 类型注解

**强制要求**: 所有公共函数必须使用类型注解

```python
from typing import List, Dict, Optional, Tuple, Union

# ✅ 正确: 完整的类型注解
def load_level(level_id: str) -> Dict[str, any]:
    """加载关卡数据"""
    return {}

def get_tile(x: int, y: int) -> Optional[Tile]:
    """获取瓦片，不存在返回None"""
    return None

def calculate_path(start: Tuple[int, int],
                  end: Tuple[int, int]) -> List[Tuple[int, int]]:
    """计算路径"""
    return []

class GridManager:
    def __init__(self, grid_size: int) -> None:
        self.grid_size: int = grid_size
        self.tiles: List[List[Tile]] = []

# ❌ 错误: 缺少类型注解
def load_level(level_id):  # 缺少参数和返回值类型
    return {}

def get_tile(x, y):  # 缺少类型
    return None
```

### 3.4 函数设计

#### 单一职责
```python
# ✅ 正确: 一个函数做一件事
def load_level_data(level_id: str) -> Dict:
    """只负责加载数据"""
    with open(f"data/levels/level_{level_id}.json") as f:
        return json.load(f)

def parse_level_data(data: Dict) -> Level:
    """只负责解析数据"""
    return Level(data)

# ❌ 错误: 一个函数做太多事
def load_and_parse_level(level_id: str) -> Level:
    """既加载又解析，职责不单一"""
    with open(f"data/levels/level_{level_id}.json") as f:
        data = json.load(f)
    return Level(data)
```

#### 参数数量
```python
# ✅ 正确: 参数不超过5个
def create_tile(x: int, y: int, tile_type: TileType,
               rotation: int = 0) -> Tile:
    return Tile(x, y, tile_type, rotation)

# ⚠️ 参数过多: 考虑使用配置对象
def create_tile(x, y, tile_type, rotation, size, color,
               texture, is_clickable, sound_effect):  # 太多参数
    pass

# ✅ 改进: 使用配置类
@dataclass
class TileConfig:
    x: int
    y: int
    tile_type: TileType
    rotation: int = 0
    size: int = 64
    color: str = "#FFFFFF"

def create_tile(config: TileConfig) -> Tile:
    return Tile(config)
```

#### 避免副作用
```python
# ✅ 正确: 纯函数，无副作用
def calculate_rotation(current: int, delta: int) -> int:
    """计算新的旋转角度"""
    return (current + delta) % 360

# ❌ 错误: 有副作用
global_state = {}

def calculate_rotation(current: int, delta: int) -> int:
    """修改全局状态，不推荐"""
    global_state['last_rotation'] = current  # 副作用
    return (current + delta) % 360
```

### 3.5 错误处理

```python
# ✅ 正确: 具体的异常类型
def load_level(level_id: str) -> Level:
    """加载关卡"""
    try:
        with open(f"data/levels/level_{level_id}.json") as f:
            data = json.load(f)
    except FileNotFoundError:
        logger.error(f"Level file not found: {level_id}")
        raise LevelNotFoundError(f"Level {level_id} does not exist")
    except json.JSONDecodeError as e:
        logger.error(f"Invalid level data: {level_id}", exc_info=True)
        raise LevelDataError(f"Level {level_id} has invalid format")

    return parse_level_data(data)

# ❌ 错误: 捕获所有异常
def load_level(level_id: str) -> Level:
    try:
        # ...
    except Exception:  # 太宽泛
        return None  # 吞掉异常，无法调试

# ❌ 错误: 空异常处理
def load_level(level_id: str) -> Level:
    try:
        # ...
    except:  # 捕获所有异常（包括系统异常）
        pass  # 静默失败，严重错误
```

#### 自定义异常
```python
# ✅ 正确: 定义清晰的异常层次
class GameError(Exception):
    """游戏基础异常"""
    pass

class LevelError(GameError):
    """关卡相关异常"""
    pass

class LevelNotFoundError(LevelError):
    """关卡未找到"""
    pass

class LevelDataError(LevelError):
    """关卡数据错误"""
    pass

class GridError(GameError):
    """网格相关异常"""
    pass
```

### 3.6 面向对象设计

#### SOLID原则

**S - 单一职责**
```python
# ✅ 正确
class LevelLoader:
    """只负责加载关卡数据"""
    def load(self, level_id: str) -> Dict:
        pass

class LevelParser:
    """只负责解析关卡数据"""
    def parse(self, data: Dict) -> Level:
        pass

# ❌ 错误
class LevelManager:
    """既加载又解析又渲染，职责过多"""
    def load(self, level_id: str):
        pass
    def parse(self, data: Dict):
        pass
    def render(self, level: Level):
        pass
```

**O - 开闭原则**
```python
# ✅ 正确: 对扩展开放，对修改关闭
from abc import ABC, abstractmethod

class Tile(ABC):
    @abstractmethod
    def rotate(self) -> None:
        pass

class RotatableTile(Tile):
    def rotate(self) -> None:
        self.rotation = (self.rotation + 90) % 360

class FixedTile(Tile):
    def rotate(self) -> None:
        pass  # 不旋转

# 添加新类型时不需要修改现有代码
class AnimatedTile(Tile):
    def rotate(self) -> None:
        self.start_animation()
```

**L - 里氏替换**
```python
# ✅ 正确: 子类可以替换父类
class Shape:
    def get_area(self) -> float:
        return 0.0

class Square(Shape):
    def __init__(self, size: float):
        self.size = size

    def get_area(self) -> float:
        return self.size * self.size  # 遵循父类契约

# ❌ 错误: 违反里氏替换
class ImmutableSquare(Shape):
    def get_area(self) -> float:
        raise NotImplementedError()  # 破坏父类契约
```

**I - 接口隔离**
```python
# ✅ 正确: 小而专注的接口
class Clickable(ABC):
    @abstractmethod
    def on_click(self) -> None:
        pass

class Rotatable(ABC):
    @abstractmethod
    def rotate(self, angle: int) -> None:
        pass

class InteractiveTile(Clickable, Rotatable):
    """需要两个功能时组合接口"""
    pass

# ❌ 错误: 臃肿的接口
class TileInterface(ABC):
    @abstractmethod
    def on_click(self):
        pass

    @abstractmethod
    def rotate(self):
        pass

    @abstractmethod
    def animate(self):
        pass

    # 强迫所有实现类实现所有方法，即使不需要
```

**D - 依赖倒置**
```python
# ✅ 正确: 依赖抽象
class GameEngine:
    def __init__(self, renderer: Renderer):  # 依赖抽象
        self.renderer = renderer

# 可以传入任何Renderer实现
engine = GameEngine(PygameRenderer())
engine = GameEngine(OpenGLRenderer())

# ❌ 错误: 依赖具体实现
class GameEngine:
    def __init__(self):
        self.renderer = PygameRenderer()  # 硬编码依赖
```

### 3.7 代码组织

#### 类内顺序
```python
class GridManager:
    """
    网格管理器

    类内成员顺序:
    1. 类变量
    2. __init__
    3. 属性(@property)
    4. 公共方法
    5. 私有方法
    6. 特殊方法(__str__, __repr__等)
    """

    # 1. 类变量
    MAX_SIZE = 8

    # 2. 初始化
    def __init__(self, size: int):
        self.size = size
        self._tiles: List[List[Tile]] = []

    # 3. 属性
    @property
    def tile_count(self) -> int:
        return self.size * self.size

    # 4. 公共方法
    def rotate_tile(self, x: int, y: int) -> bool:
        """旋转瓦片"""
        return self._apply_rotation(x, y, 90)

    def check_connectivity(self) -> bool:
        """检查连通性"""
        return self._find_path() is not None

    # 5. 私有方法
    def _apply_rotation(self, x: int, y: int, angle: int) -> bool:
        """应用旋转"""
        pass

    def _find_path(self) -> Optional[List[Tuple[int, int]]]:
        """查找路径"""
        pass

    # 6. 特殊方法
    def __str__(self) -> str:
        return f"GridManager({self.size}x{self.size})"

    def __repr__(self) -> str:
        return f"GridManager(size={self.size})"
```

---

## 4. 数据结构与算法规范

### 4.1 使用合适的数据结构

```python
# ✅ 正确: 根据使用场景选择
from collections import deque
from typing import Set, Dict

# 频繁查找: 使用集合
visited_tiles: Set[Tuple[int, int]] = set()

# 键值映射: 使用字典
tile_map: Dict[Tuple[int, int], Tile] = {}

# 队列操作: 使用deque
bfs_queue: deque = deque()

# ❌ 错误: 使用不当
visited_tiles: List[Tuple[int, int]] = []  # 查找O(n)，应用set O(1)
if (x, y) in visited_tiles:  # 慢
    pass
```

### 4.2 算法复杂度要求

- **连通性检测**: O(N²) 或更优（N为网格边长）
- **路径查找**: O(N²) 或更优
- **旋转操作**: O(1)
- **关卡加载**: O(N²)

```python
# ✅ 正确: O(N²) BFS算法
def find_path(self, start: Tuple[int, int],
             end: Tuple[int, int]) -> Optional[List]:
    """BFS查找路径"""
    queue = deque([start])
    visited = {start}

    while queue:
        current = queue.popleft()
        if current == end:
            return self._reconstruct_path(current)

        for neighbor in self._get_neighbors(current):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return None

# ❌ 错误: O(N⁴) 暴力算法
def find_path(self, start, end):
    """检查所有可能路径（指数级复杂度）"""
    all_paths = self._generate_all_paths()  # 指数级
    for path in all_paths:
        if path.start == start and path.end == end:
            return path
    return None
```

---

## 5. 配置与常量管理

### 5.1 配置文件规范

```python
# src/config/constants.py
"""
游戏常量定义

所有魔法数字必须定义为常量
"""

# 网格相关
MIN_GRID_SIZE = 3
MAX_GRID_SIZE = 8
DEFAULT_GRID_SIZE = 4

# 瓦片相关
TILE_SIZE_PX = 64
ROTATION_STEP = 90
ROTATION_DURATION_MS = 300

# 路径相关
LEVELS_DIR = "data/levels"
ASSETS_DIR = "assets"
SPRITES_DIR = f"{ASSETS_DIR}/sprites"

# 游戏逻辑
VICTORY_DELAY_MS = 1000
BGM_GAME_VOLUME = 0.2

# ✅ 使用常量
from src.config.constants import TILE_SIZE_PX, ROTATION_STEP

tile_size = TILE_SIZE_PX
rotation = (current_rotation + ROTATION_STEP) % 360

# ❌ 使用魔法数字
tile_size = 64  # 什么含义？
rotation = (current_rotation + 90) % 360  # 为什么是90？
```

### 5.2 配置文件加载

```python
# data/config/game_config.json
{
  "grid": {
    "min_size": 3,
    "max_size": 8,
    "default_size": 4
  },
  "animation": {
    "rotation_duration_ms": 300,
    "current_flow_speed": 2.0
  },
  "audio": {
    "bgm_volume": 1.0,
    "bgm_game_volume": 0.2,
    "sfx_volume": 0.8
  }
}

# src/config/config_manager.py
import json
from pathlib import Path
from typing import Any

class ConfigManager:
    """配置管理器（单例）"""

    _instance = None
    _config = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def load(self, config_path: str = 'data/config/game_config.json'):
        """加载配置"""
        with open(config_path, 'r', encoding='utf-8') as f:
            self._config = json.load(f)

    def get(self, key_path: str, default: Any = None) -> Any:
        """
        获取配置值

        Args:
            key_path: 点分隔的键路径，如 'grid.default_size'
            default: 默认值
        """
        keys = key_path.split('.')
        value = self._config

        for key in keys:
            if isinstance(value, dict) and key in value:
                value = value[key]
            else:
                return default

        return value

# 使用
config = ConfigManager()
config.load()

grid_size = config.get('grid.default_size', 4)
rotation_duration = config.get('animation.rotation_duration_ms', 300)
```

---

## 6. 测试规范

### 6.1 测试要求

- **单元测试覆盖率**: 核心逻辑 ≥ 80%
- **测试命名**: `test_<功能>_<场景>_<预期结果>`
- **测试隔离**: 每个测试独立，无依赖
- **测试速度**: 单个测试 < 100ms

### 6.2 测试结构

```python
# tests/unit/test_grid_manager.py
import unittest
from src.core.grid.grid_manager import GridManager
from src.core.grid.tile_type import TileType

class TestGridManager(unittest.TestCase):
    """网格管理器测试"""

    def setUp(self):
        """每个测试前执行"""
        self.manager = GridManager(grid_size=4)

    def tearDown(self):
        """每个测试后执行"""
        self.manager = None

    # 测试命名: test_<方法>_<场景>_<结果>
    def test_rotate_tile_valid_position_returns_true(self):
        """测试: 旋转有效位置的瓦片应返回True"""
        # Arrange (准备)
        x, y = 0, 0

        # Act (执行)
        result = self.manager.rotate_tile(x, y)

        # Assert (断言)
        self.assertTrue(result)

    def test_rotate_tile_invalid_position_returns_false(self):
        """测试: 旋转无效位置应返回False"""
        x, y = 10, 10  # 超出范围

        result = self.manager.rotate_tile(x, y)

        self.assertFalse(result)

    def test_check_connectivity_connected_grid_returns_true(self):
        """测试: 已连接的网格应返回True"""
        # 设置一个已连接的网格
        self._setup_connected_grid()

        result = self.manager.check_connectivity()

        self.assertTrue(result)

    def _setup_connected_grid(self):
        """辅助方法: 设置已连接的网格"""
        # 配置网格使其连通
        pass

# ❌ 错误的测试
class TestGridManager(unittest.TestCase):
    def test1(self):  # 命名不清晰
        pass

    def test_rotate_tile(self):  # 没有描述场景和预期
        self.manager.rotate_tile(0, 0)  # 没有断言

    def test_multiple_things(self):  # 一个测试检查多个功能
        self.manager.rotate_tile(0, 0)
        self.manager.check_connectivity()
        self.manager.load_level("001")
```

### 6.3 Mock与Stub

```python
from unittest.mock import Mock, patch, MagicMock

class TestLevelLoader(unittest.TestCase):

    @patch('builtins.open', create=True)
    @patch('json.load')
    def test_load_level_valid_file_returns_data(self, mock_json, mock_open):
        """测试: 加载有效文件应返回数据"""
        # Mock文件读取
        mock_open.return_value.__enter__.return_value = Mock()
        mock_json.return_value = {'level_id': '001', 'grid_size': 4}

        loader = LevelLoader()
        result = loader.load('001')

        self.assertEqual(result['level_id'], '001')
        mock_open.assert_called_once()
```

---

## 7. 性能优化规范

### 7.1 优化原则

1. **过早优化是万恶之源**: 先保证正确性，再优化
2. **测量再优化**: 使用性能分析工具定位瓶颈
3. **算法优于技巧**: 优先优化算法复杂度
4. **可读性优先**: 不牺牲可读性的前提下优化

### 7.2 常见优化技巧

```python
# ✅ 正确: 使用列表推导（更快）
squares = [x * x for x in range(1000)]

# ❌ 错误: 使用循环append（更慢）
squares = []
for x in range(1000):
    squares.append(x * x)

# ✅ 正确: 使用join拼接字符串
result = ''.join(string_list)

# ❌ 错误: 使用+拼接（O(n²)）
result = ''
for s in string_list:
    result += s

# ✅ 正确: 缓存计算结果
from functools import lru_cache

@lru_cache(maxsize=128)
def expensive_calculation(n: int) -> int:
    # 复杂计算
    return result

# ✅ 正确: 使用生成器节省内存
def read_large_file(path: str):
    with open(path) as f:
        for line in f:  # 生成器，按需读取
            yield line.strip()

# ❌ 错误: 一次性加载全部（内存占用大）
def read_large_file(path: str):
    with open(path) as f:
        return [line.strip() for line in f]  # 全部加载到内存
```

### 7.3 性能监控

```python
from src.utils.logger import log_performance
import time

def profile_function(func):
    """性能分析装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        result = func(*args, **kwargs)
        duration_ms = (time.perf_counter() - start) * 1000

        log_performance(func.__name__, duration_ms)

        # 如果超过阈值则警告
        if duration_ms > 100:  # 100ms阈值
            logger.warning(f"{func.__name__} took {duration_ms:.2f}ms (slow)")

        return result
    return wrapper

@profile_function
def load_level(level_id: str) -> Level:
    """加载关卡"""
    pass
```

---

## 8. 安全规范

### 8.1 输入验证

```python
# ✅ 正确: 验证所有输入
def load_level(level_id: str) -> Level:
    """加载关卡"""
    # 验证格式
    if not re.match(r'^\d{3}$', level_id):
        raise ValueError(f"Invalid level ID format: {level_id}")

    # 验证范围
    level_num = int(level_id)
    if not 1 <= level_num <= 999:
        raise ValueError(f"Level ID out of range: {level_id}")

    # 防止路径遍历
    safe_path = Path(LEVELS_DIR) / f"level_{level_id}.json"
    if not safe_path.resolve().is_relative_to(Path(LEVELS_DIR).resolve()):
        raise SecurityError("Path traversal detected")

    # 加载文件
    with open(safe_path) as f:
        return json.load(f)

# ❌ 错误: 不验证输入
def load_level(level_id: str) -> Level:
    path = f"data/levels/{level_id}.json"  # 可能路径遍历
    with open(path) as f:
        return json.load(f)
```

### 8.2 避免注入攻击

```python
# ✅ 正确: 使用参数化
import sqlite3

def get_user_score(user_id: int) -> int:
    conn = sqlite3.connect('game.db')
    cursor = conn.execute(
        "SELECT score FROM users WHERE id = ?",
        (user_id,)  # 参数化查询
    )
    return cursor.fetchone()[0]

# ❌ 错误: SQL注入风险
def get_user_score(user_id: str) -> int:
    conn = sqlite3.connect('game.db')
    cursor = conn.execute(
        f"SELECT score FROM users WHERE id = {user_id}"  # 危险！
    )
    return cursor.fetchone()[0]
```

---

## 9. 文档与注释规范

### 9.1 注释原则

- **代码即文档**: 优先编写自解释的代码
- **注释"为什么"**: 解释原因，而非描述代码
- **保持同步**: 代码变更时更新注释
- **避免废话**: 不要写显而易见的注释

```python
# ✅ 正确: 解释"为什么"
# 使用BFS而非DFS，因为需要最短路径
path = self._bfs_shortest_path(start, end)

# 旋转角度必须是360的因数，确保可以回到原位
assert rotation % 90 == 0

# ❌ 错误: 重复代码内容
# 将rotation加90
rotation = rotation + 90

# 创建GridManager实例
manager = GridManager()
```

### 9.2 文档字符串

参见《文档编写规范》第4节。

---

## 10. 代码审查检查清单

### 10.1 功能性
- [ ] 代码实现了需求功能
- [ ] 边界条件处理正确
- [ ] 错误处理完善
- [ ] 无逻辑错误

### 10.2 代码质量
- [ ] 符合代码规范
- [ ] 命名清晰有意义
- [ ] 无重复代码
- [ ] 函数职责单一
- [ ] 复杂度合理（圈复杂度≤10）

### 10.3 性能
- [ ] 算法复杂度合理
- [ ] 无明显性能问题
- [ ] 资源使用合理

### 10.4 安全性
- [ ] 输入验证完善
- [ ] 无安全漏洞
- [ ] 敏感信息保护

### 10.5 测试
- [ ] 单元测试覆盖充分
- [ ] 测试用例合理
- [ ] 所有测试通过

### 10.6 文档
- [ ] 公共API有文档
- [ ] 复杂逻辑有注释
- [ ] 相关文档已更新

---

## 11. 工具与自动化

### 11.1 代码检查工具

```bash
# 安装工具
pip install pylint black isort mypy

# 代码格式化（Black）
black src/

# 导入排序（isort）
isort src/

# 静态检查（Pylint）
pylint src/

# 类型检查（mypy）
mypy src/
```

### 11.2 Git Hooks

创建 `.git/hooks/pre-commit`:

```bash
#!/bin/bash
# Pre-commit hook: 代码质量检查

echo "Running code quality checks..."

# 格式化代码
black src/ --check
if [ $? -ne 0 ]; then
    echo "❌ Code formatting failed. Run 'black src/' to fix."
    exit 1
fi

# 导入排序
isort src/ --check
if [ $? -ne 0 ]; then
    echo "❌ Import sorting failed. Run 'isort src/' to fix."
    exit 1
fi

# 类型检查
mypy src/
if [ $? -ne 0 ]; then
    echo "❌ Type checking failed."
    exit 1
fi

# 运行测试
python -m pytest tests/
if [ $? -ne 0 ]; then
    echo "❌ Tests failed."
    exit 1
fi

echo "✅ All checks passed!"
exit 0
```

---

## 12. 常见问题

### Q1: 如何平衡代码质量和开发速度？
**A**:
1. 优先保证核心模块质量
2. 使用自动化工具节省时间
3. 在代码审查时把关
4. 技术债务要及时偿还

### Q2: 旧代码不符合规范怎么办？
**A**:
1. 新代码必须符合规范
2. 修改旧代码时顺带重构
3. 制定重构计划逐步改进
4. 不要为了规范而过度重构

### Q3: 规范太多记不住怎么办？
**A**:
1. 使用自动化工具（Black、Pylint）
2. IDE配置代码模板
3. 代码审查互相学习
4. 重点记住核心原则

---

## 13. 文档变更记录

| 版本 | 日期 | 修改人 | 修改内容 |
|------|------|--------|----------|
| v1.0.0 | 2026-01-19 | Claude | 初始版本，定义完整的开发规范 |

---

**重要提示**:
1. 本规范是强制要求，不是建议
2. 所有代码必须通过代码审查
3. 质量和速度同等重要
4. 持续改进，及时反馈问题
